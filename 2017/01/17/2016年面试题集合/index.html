<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Android 面试选题题库：Android基础模考：http://www.51mokao.com/testpractice?id=356554
Android选择题集锦：http://wenku.baidu.com/view/5ef53dd65022aaea998f0f4a.html
java面试选择题库:http://www.360doc.com/content/13/0504/17/9929">
<meta property="og:type" content="article">
<meta property="og:title" content="2016年面试集合">
<meta property="og:url" content="http://yoursite.com/2017/01/17/2016年面试题集合/index.html">
<meta property="og:site_name" content="day day up">
<meta property="og:description" content="Android 面试选题题库：Android基础模考：http://www.51mokao.com/testpractice?id=356554
Android选择题集锦：http://wenku.baidu.com/view/5ef53dd65022aaea998f0f4a.html
java面试选择题库:http://www.360doc.com/content/13/0504/17/9929">
<meta property="og:updated_time" content="2017-01-16T16:45:21.832Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2016年面试集合">
<meta name="twitter:description" content="Android 面试选题题库：Android基础模考：http://www.51mokao.com/testpractice?id=356554
Android选择题集锦：http://wenku.baidu.com/view/5ef53dd65022aaea998f0f4a.html
java面试选择题库:http://www.360doc.com/content/13/0504/17/9929">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/01/17/2016年面试题集合/"/>





  <title> 2016年面试集合 | day day up </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">day day up</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/17/2016年面试题集合/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="weihuan chen">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="day day up">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="day day up" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                2016年面试集合
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-17T00:39:24+08:00">
                2017-01-17
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Android-面试选题题库："><a href="#Android-面试选题题库：" class="headerlink" title="Android 面试选题题库："></a>Android 面试选题题库：</h2><p><a href="http://www.51mokao.com/testpractice?id=356554" target="_blank" rel="external">Android基础模考：http://www.51mokao.com/testpractice?id=356554</a></p>
<p><a href="http://wenku.baidu.com/view/5ef53dd65022aaea998f0f4a.html" target="_blank" rel="external">Android选择题集锦：http://wenku.baidu.com/view/5ef53dd65022aaea998f0f4a.html</a></p>
<p><a href="http://www.360doc.com/content/13/0504/17/992979_282936782.shtml" target="_blank" rel="external">java面试选择题库:http://www.360doc.com/content/13/0504/17/992979_282936782.shtml</a></p>
<h3 id="1-笔试题"><a href="#1-笔试题" class="headerlink" title="1.笔试题"></a>1.笔试题</h3><p>1.队列是一种（A）的线性表：</p>
<p>A.先进先出</p>
<p>B.先进后出</p>
<p>C.只能插入</p>
<p>D.只能删除</p>
<p>2.设有序表有1000个元素，则用二分查找查找元素x最多需要比较（）次。</p>
<p>A.25</p>
<p>B.10</p>
<p>C.7</p>
<p>D.1</p>
<p>3.双向链表的一个结点有（B）个指针</p>
<p>A.1</p>
<p>B.2</p>
<p>C.0</p>
<p>D.3</p>
<p>4.设有5000个无序的元素，希望用最快的速度挑选出其中前50个最大的元素，最好选用（）法</p>
<p>A.冒泡排序</p>
<p>B.快速排序</p>
<p>C.堆排序</p>
<p>D.基数排序</p>
<p>5.对于大文件的排序要研究在外设上的排序技术，即（）</p>
<p>A.快速排序法</p>
<p>B.内排序法</p>
<p>C.外排序法</p>
<p>D.交叉排序法</p>
<p>6.下列关于栈的叙述中正确的是（）</p>
<p>A.在栈中只能插入数据</p>
<p>B.在栈中只能删除数据</p>
<p>C.栈是先进先出的线性表</p>
<p>D.栈是先进后出的线性表</p>
<p>7.表达式（A）的值是整数类型</p>
<p>A.15/2</p>
<p>B.15/2+2.0</p>
<p>C.25/5.0</p>
<p>D.0.5*10</p>
<p>8.二叉树的第k层的结点数最多为（）</p>
<p>A.$$2^k$$-1</p>
<p>B.2k+1</p>
<p>C.k-1</p>
<p>D.$$2^{k-1}$$</p>
<p>9.下列属于SAX解析xml文件的优点的是（）</p>
<p>A.将整个文档数在内存中，便于操作，支持删除，修改，重新排列等多种功能</p>
<p>B.不用事先调入整个文档，占用资源少</p>
<p>C.整个文档调入内存，浪费时间和空间</p>
<p>D.不是长久驻留在内存，数据不是持久的，事件过后，若没有保存数据，数据就会消失；</p>
<p>10.在android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数据版本进行管理的方法可以是（）</p>
<p>A.getWriteableDatabase()</p>
<p>B.getReadableDatabase()</p>
<p>C.getDatabase()</p>
<p>D.getAbleDatabase()</p>
<p>11.Android关于service生命周期的onCreate()和onStart()说法正确的是（）</p>
<p>A.当第一次启动的时候先后调用onCreate()和onStart()方法</p>
<p>B.当第二次启动的时候只会调用onCrete（）方法</p>
<p>C.如果service已经启动，将先调用onCreate()和onStart()方法</p>
<p>D.如果service已经启动，只会执行onStart()方法，不在执行onCreate()方法</p>
<p>12.下面退出Activit错误的方法是（c）</p>
<p>A.finish()</p>
<p>B.抛出异常强制退出</p>
<p>C.Sysem.exit(0)</p>
<p>D.onStop()</p>
<p>13.</p>
<h3 id="2-填空题"><a href="#2-填空题" class="headerlink" title="2.填空题"></a>2.填空题</h3><p>1.android中常用的四大布局是：</p>
<p>2.android的四大组件是：</p>
<p>3.java.io中的objectinputstream和objectoutputstream类主要用于：</p>
<p>4.android中的service的实现方法是：</p>
<p>5.activity一般会重载7个方法用来维护其生命周期：</p>
<p>6.android的数据存储的方式有：</p>
<p>7.当启动一个Activity并且新的Activity执行完后需要返回到启动它的Activit来执行的回调函数是：</p>
<p>8.请说明String一下几个方法的用处，String abc=”opendoor”;</p>
<p>abc.vauleOf():__</p>
<p>abc.contains(charSe):__</p>
<p>abc.charAt(4):__</p>
<p>abc.substring(3):__</p>
<p>9.eclipse面板上的project目录里的clean有什么作用？</p>
<p>10.有三个Activity A、B 、C， A为主activity， 现在从A&gt;B&gt;C, 现在位于C, 如果想从C调至A,并执行A里面的onNewIntent()方法，该为A设置那种启动方式？</p>
<p>11.Android 的数据存储的方式有哪几种？分别是？</p>
<h3 id="3-面试题"><a href="#3-面试题" class="headerlink" title="3.面试题"></a>3.面试题</h3><p><strong>1.为啥加载图片要使用glide？使用这个glide加载的原理？</strong></p>
<p><strong>2.mvp设计模式的了解？</strong></p>
<p>1)层级责任</p>
<p>Model:       负责数据的检索,持久化等操作</p>
<p>View:         负责UI的绘制和用户的交互</p>
<p>Presenter: 作为Model和View的中间协调部分,负责两者之间的业务逻辑处理</p>
<p>2)MVP的优缺点</p>
<p>优点:降低耦合，层级职责更明显，易于单元测试</p>
<p>缺点:造成类数量爆炸，代码复杂度和学习成本高，在某些场景下presenter的复用会产生接口冗余</p>
<p><strong>3.WebView加载html5如何通过java代码与js代码进行交换的。还有如何把一个网页这么大当做一个图片来进行加载？</strong></p>
<p><strong>4.事件分发是怎么进行分发的？</strong></p>
<p><strong>5.自定义View，自定义View和自定义ViewGroup.对子控件的测量的是在哪个方法当中？</strong></p>
<p><strong>6什么是强引用？弱引用？虚引用的区别?</strong></p>
<p>1)强引用</p>
<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。 </p>
<p>2)软引用</p>
<p>如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 </p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。 </p>
<p>3)弱引用（WeakReference）<br>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 </p>
<p><strong>7.Android中有哪些内存泄漏的情况？handler是否会内存泄漏？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">一般内存泄漏(traditional memory leak)的原因是：当该对象的所有引用都已经释放了，对象仍未被释放。</div><div class="line"></div><div class="line">1.有哪些内存泄漏的情况</div><div class="line">1）.如果持有对象的强引用，垃圾回收器是无法在内存中回收这个对象。(Static Activities ,Static Views)</div><div class="line">2）.监听器忘记注销</div><div class="line">3）.流和游标没有关闭</div><div class="line"></div><div class="line">2.handler是否会内存泄漏？</div><div class="line">定义匿名的Runnable，用匿名类Handler执行。Runnable内部类会持有外部类的隐式引用，被传递到Handler的消息队列MessageQueue中，在Message消息没有被处理之前，Activity实例不会被销毁了，于是导致内存泄漏。</div></pre></td></tr></table></figure>
<p>详情：<a href="http://www.jb51.net/article/92337.htm" target="_blank" rel="external">http://www.jb51.net/article/92337.htm</a></p>
<p><strong>8.如何去学习新的知识？</strong></p>
<p>1 ) 关注github</p>
<p>2）关注博客</p>
<p>3）关注技术论坛</p>
<p><strong>9.对公司的选择是什么？</strong></p>
<p><strong>10.你的职业规划是什么？</strong></p>
<p><strong>11.glide的加载的时候几种解码格式的区别？</strong></p>
<p><strong>12.LruCache算法的原理?</strong></p>
<p>查了下官方资料，是这样定义的：</p>
<p>LruCache 是对限定数量的缓存对象持有强引用的缓存，每一次缓存对象被访问，都会被移动到队列的头部。当有对象要被添加到已经达到数量上限的 LruCache 中，队列尾部的对象将会被移除，而且可能会被垃圾回收器回收。LruCache 中的 Lru 指的是“Least Recently Used-近期最少使用<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="external">算法</a>”。这就意味着，LruCache 是一个能够判断哪个缓存对象是近期最少使用的缓存对象，从而把最少使用的移至队尾，而近期使用的则留在队列前面了。举个例子：比如我们有a、b、c、d、e五个元素，而a、c、d、e都被访问过，唯有b元素没有访问，则b元素就成为了近期最少使用元素了，就移至在队尾了。</p>
<p>从上面的叙述中我们总结可以知道LruCache核心思想就两点：</p>
<p>1、LruCache使用的是近期最少使用算法，近期使用最少的将会移至到队尾，而近期刚刚使用的则会移至到头部。</p>
<p>2、LruCache缓存的大小是限定的（限定的大小由我们定义），当LruCache存储空间满了就会移除队尾的而为新的对象的加入腾出控件。</p>
<p><strong>13.listView的是如何优化？</strong></p>
<p>1）listview现在最常用也拥有很好的性能的优化方式是在Adapter中使用静态的ViewHolder</p>
<p>2）在Adapter的代码中，在getView方法里首先判断convertView是否为空，若为空则加载相应布局，若不为空则直接使用该布局，这能够很有效的使用Android为listview提供的缓存机制，只加载一屏的布局，之后滑动出来的item使用的是之前已经加载的布局的缓存；</p>
<p>3）listView的item的图片使用三级缓存加上异步加载</p>
<p>4）分页加载数据,；滑动是不加载图片，滑动停止是加载图片</p>
<p><strong>14.如果后台的Activity被系统回收了，如果在被系统回收之前保存当前状态？</strong></p>
<p>重写onSaveInstanceState()方法，在此方法中保存需要保存的数据，该方法将会在activity被回收之前调用。通过重写onRestoreInstanceState()方法可以从中提取保存好的数据</p>
<p>e</p>
<p><strong>15.请介绍下ContentProvider是如何实现数据共享的？</strong></p>
<p>一个程序可以通过实现一个Content provider的抽象接口将自己的数据完全暴露出去，而且Content providers是以类似数据库中表的方式将数据暴露。Content providers存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。</p>
<p>要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。</p>
<p>如何通过一套标准及统一的接口获取其他应用程序暴露的数据？Android提供了ContentResolver，外界的程序可以通过ContentResolver接口访问ContentProvider提供的数据。</p>
<p><strong>16.注册广播有几种方式，这些方式有何优缺点？请谈谈Android引入广播机制的用意。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">首先写一个类要继承BroadcastReceiver</div><div class="line">第一种:在清单文件中声明,添加</div><div class="line">&lt;receive android:name=&quot;.IncomingSMSReceiver &quot; &gt;</div><div class="line">&lt;intent-filter&gt;</div><div class="line">   &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;)</div><div class="line">&lt;intent-filter&gt;</div><div class="line">&lt;receiver&gt;</div><div class="line">第二种使用代码进行注册如:</div><div class="line">IntentFilter filter =  new IntentFilter(&quot;android.provider.Telephony.SMS_RECEIVED&quot;);</div><div class="line">IncomingSMSReceiver receiver = new IncomgSMSReceiver();</div><div class="line">registerReceiver(receiver.filter);</div><div class="line">两种注册类型的区别是：</div><div class="line">1)第一种不是常驻型广播，也就是说广播跟随程序的生命周期。</div><div class="line">2)第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</div></pre></td></tr></table></figure>
<p><strong>17.简述Service两种启动方式的不同点？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">第一种：采用start的方式开启服务</div><div class="line">1）使用Service的步骤：</div><div class="line">1.定义一个类继承Service</div><div class="line">2.在Manifest.xml文件中配置该Service</div><div class="line">3.使用Context的startService(Intent)方法启动该Service</div><div class="line">4.不再使用时，调用stopService(Intent)方法停止该服务</div><div class="line"></div><div class="line">2）使用这种start方式启动的Service的生命周期如下：</div><div class="line">onCreate()---&gt;onStartCommand()（onStart()方法已过时） ---&gt; onDestory()</div><div class="line">说明：如果服务已经开启，不会重复的执行onCreate()， 而是会调用onStart()和onStartCommand()。</div><div class="line">服务停止的时候调用 onDestory()。服务只会被停止一次。</div><div class="line"></div><div class="line">3）特点</div><div class="line">一旦服务开启跟调用者(开启者)就没有任何关系了。</div><div class="line">开启者退出了，开启者挂了，服务还在后台长期的运行。</div><div class="line">开启者不能调用服务里面的方法。</div><div class="line"></div><div class="line"></div><div class="line">第二种：采用bind的方式开启服务</div><div class="line">1）使用Service的步骤：</div><div class="line">1.定义一个类继承Service</div><div class="line">2.在Manifest.xml文件中配置该Service</div><div class="line">3.使用Context的bindService(Intent, ServiceConnection, int)方法启动该Service</div><div class="line">4.不再使用时，调用unbindService(ServiceConnection)方法停止该服务</div><div class="line"></div><div class="line">2）使用这种start方式启动的Service的生命周期如下：</div><div class="line">onCreate() ---&gt;onBind()---&gt;onunbind()---&gt;onDestory()</div><div class="line">注意：绑定服务不会调用onstart()或者onstartcommand()方法</div><div class="line"></div><div class="line">3）特点</div><div class="line">bind的方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉。</div><div class="line">绑定者可以调用服务里面的方法。</div></pre></td></tr></table></figure>
<p><strong>18.Activity A、B、C、D、E、F 。A是主activity ， 现在按顺序从A一直跳到F,如何实现在F按返回键退出程序？有几种方法？</strong></p>
<p>1）一种常用的方法是自定义一个Activity的栈，在程序退出时将栈中的所有的Activity进行finish。</p>
<p>2）直接杀死进程:</p>
<p>​    android.os.Process.killProcess(Process.myPid()); </p>
<p>3）使用方法是使用Android的Broadcast机制。在所有的Activity中注册退出程序的消息，当收到消息时调用finish方法。  然后再有退出程序功能的Activity上广播关闭消息</p>
<p>详情:<a href="http://alex-yang-xiansoftware-com.iteye.com/blog/1099207" target="_blank" rel="external">http://alex-yang-xiansoftware-com.iteye.com/blog/1099207</a></p>
<p><strong>19.什么是数据的封装？怎么理解同步？</strong></p>
<p><strong>20.现在一个正方形的图片T， 请用代码简述操作，使T去掉四角，在屏幕显示成圆形。</strong></p>
<p><strong>21.是否了解反编译？请简述?</strong></p>
<p><strong>22.说说View绘制过程和事件分发机制onTouch和onTouchEvent区别调用顺序？</strong></p>
<p><strong>23.请描述服务（Service）使用方法及需要注意的事项。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Service分为本地服务（LocalService）和远程服务（RemoteService）：</div><div class="line"></div><div class="line">1、本地服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，也不需要AIDL。相应bindService会方便很多。主进程被Kill后，服务便会终止。</div><div class="line"></div><div class="line">2、远程服务为独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。</div><div class="line"></div><div class="line">按使用方式可以分为以下三种：</div><div class="line"></div><div class="line">1、startService 启动的服务：主要用于启动一个服务执行后台任务，不进行通信。停止服务使用stopService；</div><div class="line"></div><div class="line">2、bindService 启动的服务：该方法启动的服务可以进行通信。停止服务使用unbindService；</div><div class="line"></div><div class="line">3、startService 同时也 bindService 启动的服务：停止服务应同时使用stepService与unbindService</div></pre></td></tr></table></figure>
<p>详情：<a href="http://www.cnblogs.com/linlf03/p/3296323.html" target="_blank" rel="external">http://www.cnblogs.com/linlf03/p/3296323.html</a></p>
<p><strong>24.广播（BoradCastReceiver）一般使用场景有哪些？有几种注册方式。它们有什么区别，使用时需要注意些什么事项？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.场景有哪些:</div><div class="line">监听手机开机广播，来电去电广播还有接收短信广播等等</div><div class="line">2.有几种注册方式，它们有什么区别：</div><div class="line">	可以看16题</div><div class="line">3.使用时需要注意些什么事项：</div><div class="line">  注册了一个广播一定要记得取消注册，不然容易出现泄漏</div><div class="line">  广播接收是有顺序的并且可以拦截广播</div></pre></td></tr></table></figure>
<p><strong>25.请简述ListView和Recyerview的Adapter的复用原理，这两者有什么区别，它们的优化方法有哪些？</strong></p>
<p><strong>26.请说说支付宝支付的流程和注册事项？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1.流程：</div><div class="line">1）获取订单</div><div class="line">2）订单生成签名</div><div class="line">3）生成支付信息</div><div class="line">4）调起支付</div><div class="line">5）处理支付回调结果</div><div class="line">2.注册事项</div><div class="line">1）公私钥要在使用时不能出现空格</div><div class="line">2）签名和支付信息生成要正确</div><div class="line">3）禁止多次调用同一次支付</div></pre></td></tr></table></figure>
<p><strong>27.请说说微信支付的流程和注册事项？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1）支付的流程</div><div class="line">1.获取预支付id</div><div class="line">2.准备支付订单信息</div><div class="line">3.调起微信支付</div><div class="line">4.处理微信支付的结果</div><div class="line"></div><div class="line">2）注册事项</div><div class="line">1.使用正式的签名，调试的签名和创建应用的签名要正确</div><div class="line">2.处理支付结果的类的包名要正确</div></pre></td></tr></table></figure>
<p><strong>28.轮播图是怎么样解决滑动冲突？</strong></p>
<p><strong>29.在开发的时候有没有对一些数据进行缓存？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.网络接口数据的缓存</div><div class="line">2.图片的缓存</div><div class="line">3.聊天信息的缓存</div></pre></td></tr></table></figure>
<p><strong>30.图片加载使用什么框架？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.glide</div><div class="line">2.picasso</div><div class="line">3.UniversalImageLoader</div></pre></td></tr></table></figure>
<p><strong>31.项目使用了ImageLoader 那么ImageLoader的内部原理有了解过么?</strong></p>
<p>32.你们整个团队有几个人?android开发有几个人?测试有几个?后台有几个?项目多久完成的?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.整个团队有几个人10个人</div><div class="line">2.android开发有2个人</div><div class="line">3.测试有1个</div><div class="line">4.后台有3个</div><div class="line">5.项目3个月完成</div></pre></td></tr></table></figure>
<p><strong>33.你说你会测试文档编写, 那么测试文档的格式是什么样的?</strong></p>
<p><strong>34.分享这一块你们是怎么做的呢?</strong></p>
<p><strong>35.有关Android最新信息,你都是通过什么途径获取的呢?还问了你都知道最近有什么最新信息呢？</strong></p>
<p><strong>36.Android最近比较流行的技术,有什么?你知道热修复是什么么?有没有去了解过呢?</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.Android最近比较流行的技术:</div><div class="line">RxJava Retrofit okHttp MVP hot-fix  React-Native ...</div><div class="line">2.热修复是什么?</div><div class="line">热修复其实就是通过打补丁的方法动态更新代码，能够在不重新安装应用的情况下修复bugs</div><div class="line">3.有没有去了解过?</div><div class="line">AndFix</div><div class="line">Tinker</div></pre></td></tr></table></figure>
<p><strong>37.在上一个项目你负责了哪些模块?你是通过什么技术完成的这些模块?</strong></p>
<p><strong>38.你们项目经理给你们分配任务是通过什么方式分配?分配任务的文档是什么格式的,是word文档还是什么?文档的格式是怎么样的?</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">任务分配是通过：WorkTile  或者 Tower 平台</div></pre></td></tr></table></figure>
<p><strong>39.你在开发的过程中都遇到什么问题？</strong></p>
<p><strong>40.内存优化，说说几个例子？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.listView的item的复用</div><div class="line">2.图片的三级缓存</div><div class="line">3.减少布局嵌套的层数</div><div class="line">4.在OnDraw（）方法中避免new对象</div></pre></td></tr></table></figure>
<p><strong>41.常见的设计模式，举例子？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.单例（图片加载管理类，网络请求管理类...）</div><div class="line">2.工厂模式</div><div class="line">3.策略模式（设计回调，网络请求时的回调）</div><div class="line">4.观察者模式（RxJava）</div><div class="line">5.适配器模式(lsitView 中的 adapter)</div></pre></td></tr></table></figure>
<p><strong>42.请说说Handle的原理</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">简单的说，Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理。</div><div class="line">Message Queue(消息队列)：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列</div><div class="line">Handler：可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息。</div><div class="line">Looper：是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。Looper也把消息队列里的消息广播给所有的</div><div class="line">Handler：Handler接受到消息后调用handleMessage进行处理</div><div class="line">Message：消息的类型，在Handler类中的handleMessage方法中得到单个的消息进行处理</div><div class="line">在单线程模型下，为了线程通信问题，Android设计了一个Message Queue(消息队列)，线程间可以通过该Message Queue并结合Handler和Looper组件进行信息交换。下面将对它们进行分别介绍：</div><div class="line">1. Message </div><div class="line">    Message消息，理解为线程间交流的信息，处理数据后台线程需要更新UI，则发送Message内含一些数据给UI线程。</div><div class="line">2. Handler </div><div class="line">    Handler处理者，是Message的主要处理者，负责Message的发送，Message内容的执行处理。后台线程就是通过传进来的 Handler对象引用来sendMessage(Message)。而使用Handler，需要implement 该类的 handleMessage(Message)方法，它是处理这些Message的操作内容，例如Update UI。通常需要子类化Handler来实现handleMessage方法。</div><div class="line">3. Message Queue </div><div class="line">    Message Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。</div><div class="line">每个message queue都会有一个对应的Handler。Handler会向message queue通过两种方法发送消息：sendMessage或post。这两种消息都会插在message queue队尾并按先进先出执行。但通过这两种方法发送的消息执行的方式略有不同：通过sendMessage发送的是一个message对象,会被 Handler的handleMessage()函数处理；而通过post方法发送的是一个runnable对象，则会自己执行。</div><div class="line">4. Looper </div><div class="line">    Looper是每条线程里的Message Queue的管家。Android没有Global的Message Queue，而Android会自动替主线程(UI线程)建立Message Queue，但在子线程里并没有建立Message Queue。所以调用Looper.getMainLooper()得到的主线程的Looper不为NULL，但调用Looper.myLooper() 得到当前线程的Looper就有可能为NULL。对于子线程使用Looper，API Doc提供了正确的使用方法：这个Message机制的大概流程：</div><div class="line">    1. 在Looper.loop()方法运行开始后，循环地按照接收顺序取出Message Queue里面的非NULL的Message。</div><div class="line">    2. 一开始Message Queue里面的Message都是NULL的。当Handler.sendMessage(Message)到Message Queue，该函数里面设置了那个Message对象的target属性是当前的Handler对象。随后Looper取出了那个Message，则调用该Message的target指向的Hander的dispatchMessage函数对Message进行处理。在dispatchMessage方法里，如何处理Message则由用户指定，三个判断，优先级从高到低：</div><div class="line">    1) Message里面的Callback，一个实现了Runnable接口的对象，其中run函数做处理工作；</div><div class="line">    2) Handler里面的mCallback指向的一个实现了Callback接口的对象，由其handleMessage进行处理；</div><div class="line">    3) 处理消息Handler对象对应的类继承并实现了其中handleMessage函数，通过这个实现的handleMessage函数处理消息。</div><div class="line">3. Handler处理完该Message (update UI) 后，Looper则设置该Message为NULL，以便回收！</div><div class="line">    在网上有很多文章讲述主线程和其他子线程如何交互，传送信息，最终谁来执行处理信息之类的，个人理解是最简单的方法——判断Handler对象里面的Looper对象是属于哪条线程的，则由该线程来执行！ </div><div class="line">    	1. 当Handler对象的构造函数的参数为空，则为当前所在线程的Looper； </div><div class="line">2. Looper.getMainLooper()得到的是主线程的Looper对象，Looper.myLooper()得到的是当前线程的Looper对象。</div></pre></td></tr></table></figure>
<p><strong>43.Android 如何与H5互交？</strong></p>
<p><strong>44.说说5.0的新特性？你在项目中有用到了么？</strong></p>
<p><strong>1.全新Material Design设计风格</strong></p>
<p>Android Lollipop全新的设计语言是受到了多种因素影响，是一种大胆的平面化创新。换句话说，谷歌希望能够让Material Design给用户带来纸张化的体验。新的视觉语言，在基本元素的处理上，借鉴了传统的印刷设计，字体版式、网格系统、空间、比例、配色、图像使用等这些基础的平面设计规范。</p>
<p>另外，Material Design还推崇实体隐喻理念，利用实体的表面与边缘的质感打造出视觉线索，让用户感受到真实。熟悉的触感让用户可以快速的理解、认知。在设计中可以灵活的运用物质，在符合物理规律的基础上，打造出不同的使用体验。最后是是有意义而且更合理的动态效果，为了吸引用户的注意力，以及维持整个系统的连续性体验。</p>
<p><strong>2、支持多种设备</strong></p>
<p>现在无论是智能手机、平板电脑、笔记本电脑、智能电视、汽车、智能手表甚至是各种家用电子产品，谷歌的Android系统已经可以在所有设备的屏幕上出现。而这一概念与微软不谋而合，之前微软也宣布将会把Windows 10打造成跨设备跨平台的统一系统，帮助自己走出困境。</p>
<p><strong>3、全新的通知中心设计</strong></p>
<p>谷歌在Android Lollipop中加入了全新风格的通知系统。改进后的通知系统会优先显示对用户来说比较重要的信息，而将不太紧急的内容隐藏起来。用户只需要向下滑动就可以查看全部的通知内容。</p>
<p>新的通知系统另外一个很酷的新功能是在锁屏界面也可以直接查看通知消息了。不仅如此，用户还可以直接在锁屏的情况下就行回复或进入应用。另外，如果在操作手机的过程中有电话进入，也不会进行全画面切换，而是同样以弹出通知的方式告知用户。</p>
<p>详情：<a href="http://www.jb51.net/shouji/231446.html" target="_blank" rel="external">http://www.jb51.net/shouji/231446.html</a></p>
<p><strong>45.有没有做过自定义控件？举个 例子看看？</strong></p>
<p><strong>46.为啥加载图片要使用glide？使用这个glide加载的原理？</strong></p>
<p><strong>48.事件分发是怎么进行分发的？</strong></p>
<p><strong>56.方法数过多怎么解决？</strong></p>
<p>详情：<a href="http://blog.163.com/qqoowww@yeah/blog/static/17309394720164261124405/" target="_blank" rel="external">http://blog.163.com/qqoowww@yeah/blog/static/17309394720164261124405/</a></p>
<p><strong>57.APK过大,图片占用空间大怎么解决？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.使用TinyPng压缩图片</div><div class="line">2.减少没用的icon</div><div class="line">3.使用混淆</div></pre></td></tr></table></figure>
<p><strong>58.fragment生命周期,fragment与Activity传递数据的方式？</strong></p>
<p>详细：<a href="http://www.jianshu.com/p/f87baad32662" target="_blank" rel="external">http://www.jianshu.com/p/f87baad32662</a></p>
<p><strong>59.在android中，请简述jni的调用过程。</strong></p>
<p><strong>60.简述Android应用程序结构是哪些？</strong></p>
<p><strong>61.页面上现有ProgressBar 控件，请使用线程以10秒的时间完成其进度显示工作。</strong></p>
<p><strong>62.NDK是什么？</strong></p>
<p>对NDK进行了粗略的研究后，我对“NDK是什么”的理解如下：</p>
<p>　　1、NDK是一系列工具的集合。</p>
<ul>
<li>NDK提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk。这些工具对开发者的帮助是巨大的。</li>
<li>NDK集成了交叉编译器，并提供了相应的mk文件隔离CPU、平台、ABI等差异，开发人员只需要简单修改mk文件（指出“哪些文件需要编译”、“编译特性要求”等），就可以创建出so。</li>
<li>NDK可以自动地将so和Java应用一起打包，极大地减轻了开发人员的打包工作。</li>
</ul>
<p>　　2、NDK提供了一份稳定、功能有限的API头文件声明。</p>
<p>　　Google明确声明该API是稳定的，在后续所有版本中都稳定支持当前发布的API。从该版本的NDK中看出，这些API支持的功能非常有限，包含有：C标准库（libc）、标准数学库（libm）、压缩库（libz）、Log库（liblog）。</p>
<p>　　4、NDK带来什么</p>
<p>　　1) NDK的发布，使“Java+C”的开发方式终于转正，成为官方支持的开发方式。</p>
<ul>
<li>使用NDK，我们可以将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。</li>
<li>使用NDK，我们可以将需要保密的应用逻辑使用C开发。毕竟，Java包都是可以反编译的。</li>
<li>NDK促使专业so组件商的出现。（乐观猜想，要视乎Android用户的数量）</li>
</ul>
<p>　　2)NDK将是Android平台支持C开发的开端。</p>
<p>　　NDK提供了的开发工具集合，使开发人员可以便捷地开发、发布C组件。同时，Google承诺在NDK后续版本中提高“可调式”能力，即提供远程的gdb工具，使我们可以便捷地调试C源码。在支持Android平台C开发，我们能感觉到Google花费了很大精力，我们有理由憧憬“C组件支持”只是Google Android平台上C开发的开端。毕竟，C程序员仍然是码农阵营中的绝对主力，将这部分人排除在Android应用开发之外，显然是不利于Android平台繁荣昌盛的。</p>
<p>详情:<a href="http://www.cnblogs.com/leaven/archive/2010/05/27/1744855.html" target="_blank" rel="external">http://www.cnblogs.com/leaven/archive/2010/05/27/1744855.html</a></p>
<p><strong>63.说说MVC的原理？</strong></p>
<p>mvc：M是指逻辑模型，V是指试图模型，C是指控制器。使用mvc的目的是将M和V实现代码分离，从而使同一个程序可以使用不同的表现形式，这与《设计模式》中的观察者模式是完全一样的。</p>
<p>Android中界面部分也采用了mvc框架：</p>
<p>1）试图层：一般采用xml文件进行界面的描述，使用的时候可以方便的引入。也可以使用JavaScript+HTML等方式作为View层，当然这里需要进行Java和Javascript之间的通讯，幸运的是，Android提供了它们之间的通信机制。</p>
<p>2）控制层：Android的控制层的重任通常落在了Activity的肩上，这句话也就暗含了不要在Activity中写代码，要通过Activity交割Model业务逻辑层处理，这样做的另外一个原因是Android中的Activity的响应时间是5s,如果耗时的操作放在这里，程序就很容易被回收掉。</p>
<p>3）模型层：对数据库的操作、对网络等的操作都应该在Model里面处理，当然对业务计算等操作也是必须放在该层的。就是应用程序的二进制数据。</p>
<p><strong>64.请谈一下Android系统的架构。</strong></p>
<p><strong>65.请简述Android常用的五种布局。</strong></p>
<p>详情：<a href="http://blog.csdn.net/chenshijun0101/article/details/6543461" target="_blank" rel="external">http://blog.csdn.net/chenshijun0101/article/details/6543461</a></p>
<p><strong>66.Android 中的Handler与Looper的作用与区别分别是什么？</strong></p>
<p><strong>67.Android 中的动画有哪几种，它们的特点和 区别是什么？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.Tween动画:</div><div class="line">	Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化。</div><div class="line">2.Frame动画:</div><div class="line">	Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。</div><div class="line">3.属性动画：</div><div class="line">	这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化，还可以实现其它高级动画</div></pre></td></tr></table></figure>
<p><strong>68.实现1+2+3+…+100 。（注意：每加一个数字输出结果，第一次输出3，不能呢使用for和while循环）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">使用递归</div></pre></td></tr></table></figure>
<p><strong>69.Android的编译原理，每一步是怎样的？</strong></p>
<p><strong>70.异常怎么处理？</strong></p>
<p>Android应用全局异常处理</p>
<p>详情：<a href="http://blog.csdn.net/itachi85/article/details/9102021" target="_blank" rel="external">http://blog.csdn.net/itachi85/article/details/9102021</a></p>
<p><strong>71.用过哪些SDk， 你有去看过是怎么实现的吗？还是仅仅只是调用API</strong></p>
<p><strong>72.上一个公司项目的框架是谁搭的？你主要负责了什么？</strong></p>
<p><strong>73.你简历上有很多图片处理的，你图片是怎么处理的？</strong></p>
<p><strong>74.Socket 如何 保存一个 长连接？</strong></p>
<p><strong>75.在数据库中 添加一个新的字段 但是不能清除以前缓存的数据 怎么做？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在update方法中根据版本号的不一样，执行添加一个新的字段的sql语句</div></pre></td></tr></table></figure>
<p><strong>76.你是怎么保证 你的app 能够收到你的推送 （通知）呢？比如你有个东西 要推送给你的客户端？</strong></p>
<p><strong>77.熟悉哪些开源框架？比如说UIL,会问到这个图片加载的底层。</strong></p>
<p><strong>78.Handler机制，AsyncTask底层怎么实现的？两者的区别？</strong></p>
<p><strong>79.Service在哪个线程启动？为什么在主线程启动？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1.Service在哪个线程启动?</div><div class="line">main线程</div></pre></td></tr></table></figure>
<p><strong>80.进程间如何通信？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.通过内容提供者</div><div class="line">2.通过远程服务aidl</div><div class="line">3.通过广播</div></pre></td></tr></table></figure>
<p><strong>81.购物车的功能是如何实现的，数据怎么获取？</strong></p>
<p><strong>82.你理解的单例模式？用在什么地方？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.单例模式?</div><div class="line">保证只存在一个对象</div><div class="line">2.一些管理类中</div></pre></td></tr></table></figure>
<p><strong>83.java线程的sleep（）， wait（） ,notify（），yield（）方法的区别？</strong></p>
<p><strong>1.sleep()</strong><br>​    使当前线程(即调用该方法的线程)暂停执行一段时间，让其他线程有机会继续执行，但它<strong>并不释放对象锁</strong>。也就是如果有Synchronized同步块，其他线程仍然不同访问共享数据。注意该方法要捕获异常。</p>
<p>比如有两个线程同时执行(没有Synchronized)，一个线程优先级为MAX_PRIORITY，另一个为MIN_PRIORITY，如果没有Sleep()方法，只有高优先级的线程执行完成后，低优先级的线程才能执行；但当高优先级的线程sleep(5000)后，低优先级就有机会执行了。<br>​    总之，<strong>sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。</strong></p>
<p><strong>2.yield()</strong><br>​    它与sleep()类似，<strong>只是不能由用户指定暂停多长时间</strong>，并且yield()方法只能让同优先级的线程有执行的机会。</p>
<p><strong>3.wait()和notify()</strong><br>​    这三个方法用于协调多个线程对共享数据的存取，所以<strong>必须在Synchronized语句块内使用这三个方法</strong>。前面说过Synchronized这个关键字用于保护共享数据，阻止其他线程对共享数据的存取。但是这样程序的流程就很不灵活了，如何才能在当前线程还没退出Synchronized数据块时让其他线程也有机会访问共享数据呢？此时就用这三个方法来灵活控制。</p>
<p>wait()方法<strong>使当前线程暂停执行并释放对象锁标志</strong>，让其他线程可以进入Synchronized数据块，当前线程被放入对象等待池中。当调用 notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中的线程能够获取锁标志；<strong>如果锁标志等待池中没有线程，则notify()不起作用</strong>。</p>
<p>详情：<a href="http://blog.csdn.net/zgrgfr/article/details/53335085" target="_blank" rel="external">http://blog.csdn.net/zgrgfr/article/details/53335085</a></p>
<p><strong>84.什么是Android ANR ? Android ANR 有几种类型？如何定位？</strong></p>
<p>ANR：Application Not Responding。在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应，当用户操作的在5s内应用程序没能做出反应，BroadcastReceiver在10秒内没有执行完毕，就会出现应用程序无响应对话框，这既是ANR。</p>
<p>避免方法：Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里（或者异步方式）来完成。主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。</p>
<p><strong>85.请描述一下Activity和Fragment的关系</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1、fragmentactivity 继承自activity，用来解决android3.0 之前没有fragment的api，所以在使用的时候需要导入support包，同时继承fragmentActivity，这样在activity中就能嵌入fragment来实现你想要的布局效果。</div><div class="line"></div><div class="line"></div><div class="line">2、当然3.0之后你就可以直接继承自Activity，并且在其中嵌入使用fragment了。</div><div class="line"></div><div class="line"></div><div class="line">3、获得Manager的方式也不同</div><div class="line"></div><div class="line">  3.0以下：getSupportFragmentManager()</div><div class="line"></div><div class="line">  3.0以上：getFragmentManager()</div></pre></td></tr></table></figure>
<p><strong>86.请比较一下Application Context和Activity Context异同？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">这是两种不同的context，也是最常见的两种.第一种中context的生命周期与Application的生命周期相关的，context随着Application的销毁而销毁，伴随application的一生，与activity的生命周期无关.第二种中的context跟Activity的生命周期是相关的，但是对一个Application来说，Activity可以销毁几次，那么属于Activity的context就会销毁多次.</div><div class="line"></div><div class="line">至于用哪种context，得看应用场景，个人感觉用Activity的context好一点，不过也有的时候必须使用Application的context.application context可以通过Context.getApplicationContext或者Activity.getApplication方法获取.</div><div class="line"></div><div class="line">还有就是，在使用context的时候，小心内存泄露，防止内存泄露，注意一下几个方面：</div><div class="line"></div><div class="line">1. 不要让生命周期长的对象引用activity context，即保证引用activity的对象要与activity本身生命周期是一样的</div><div class="line"></div><div class="line">2. 对于生命周期长的对象，可以使用application context</div><div class="line"></div><div class="line">3. 避免非静态的内部类，尽量使用静态类，避免生命周期问题，注意内部类对外部对象引用导致的生命周期变化</div><div class="line"></div><div class="line">现在回到正题，说一下android全局变量，在平时的开发过程中，有时候可能会需要一些全局数据，来让应用中的所有Activity和View都能访问到，大家在遇到这种情况时，可能首先会想到自己定义一个类，然后创建很多静态成员，android已经为我们提供了这种情况的解决方案：</div><div class="line"></div><div class="line">在Android中，有一个Application类，在Activity中可以使用getApplication（）方法获得实例，使用它就可以获得当前应用的主题、资源文件中的内容等，这个类更灵活的一个特性就是可以被继承，来添加自己的全局属性.</div></pre></td></tr></table></figure>
<p><strong>87.简述AlarmManager 和 WakeLock的使用？</strong></p>
<p><strong>88.如何对Android设备进行性能测试？</strong></p>
<p><strong>89.如果你是技术经理，你将如何设计与搭建Android应用架构？</strong></p>
<p><strong>90.简述TCP与UDP的区别</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</div><div class="line">2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</div><div class="line">3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的</div><div class="line">UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</div><div class="line">4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</div><div class="line">5、TCP首部开销20字节;UDP的首部开销小，只有8个字节</div><div class="line"></div><div class="line">6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</div></pre></td></tr></table></figure>
<p><strong>91.多线程有几种实现方法？同步有几种实现方法？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1.多线程有几种实现方法:</div><div class="line">1).继承Thread类实现多线程</div><div class="line">2).实现Runnable接口方式实现多线程</div><div class="line">3).使用ExecutorService、Callable、Future实现有返回结果的多线程</div><div class="line"></div><div class="line">2.同步有几种实现方法:</div><div class="line">synchronized</div><div class="line">wait与notify</div><div class="line">Lock</div></pre></td></tr></table></figure>
<p><strong>92.同步与异步有何异同？在什么情况下分别使用他们？</strong></p>
<p><strong>94.嵌入式操作系统内存管理有哪几种？各有何特性？</strong></p>
<p><strong>95.你后台的Activity被系统回收怎么办？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">重写onSaveInstanceState（）方法，再次方法中保存需要保存的数据，该方法会在activity被GC回收之前调用。 </div><div class="line">在onRestoreInstanceState（）方法中可以提取保存好的数据</div></pre></td></tr></table></figure>
<p><strong>96.如何退出Activity？ 如何安全退出已调用多个Activity的Application?</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1）一种常用的方法是自定义一个Activity的栈，在程序退出时将栈中的所有的Activity进行finish。</div><div class="line"></div><div class="line">2）直接杀死进程:</div><div class="line"></div><div class="line">	android.os.Process.killProcess(Process.myPid()); </div><div class="line"></div><div class="line">3）使用方法是使用Android的Broadcast机制。在所有的Activity中注册退出程序的消息，当收到消息时调用finish方法。  然后再有退出程序功能的Activity上广播关闭消息</div><div class="line"></div><div class="line">详情:http://alex-yang-xiansoftware-com.iteye.com/blog/1099207</div></pre></td></tr></table></figure>
<p><strong>97.什么是反射？它的实现的原理是什么？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1.什么是反射：</div><div class="line">也就是说,在编译时,你获取了一个指向某个并不存在你的程序空间中的对象的引用;事实上在编译时你的程序无法获知这个对象所属的类</div><div class="line"></div><div class="line">2.原理是:</div><div class="line">Java的反射机制的实现要借助于4个类：class，Constructor，Field，Method；</div><div class="line"></div><div class="line">class代表的时类对 象;</div><div class="line">Constructor－类的构造器对象;</div><div class="line">Field－类的属性对象;</div><div class="line">Method－类的方法对象。通过这四个对象我们可以粗略的看到一个类的各个组 成部分。</div><div class="line"></div><div class="line">Class：程序运行时，java运行时系统会对所有的对象进行运行时类型的处理。这项信息记录了每个对象所属的类，虚拟机通常使用运行时类型信息选择正 确的方法来执行（摘自：白皮书）。但是这些信息我们怎么得到啊，就要借助于class类对象了啊。在Object类中定义了getClass()方法。我 们可以通过这个方法获得指定对象的类对象。然后我们通过分析这个对象就可以得到我们要的信息了。</div></pre></td></tr></table></figure>
<p><strong>98.线程为什么会死锁？在java中有哪几种方式可以避免死锁？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.线程为什么会死锁?</div><div class="line">	使用的锁对象不一样</div><div class="line">2.在java中有哪几种方式可以避免死锁：</div><div class="line">	必需使用的是同一个锁</div></pre></td></tr></table></figure>
<p><strong>99.观察者模式是怎么实现的？请简述描述一下，可用类图画出？</strong></p>
<p><strong>100.Service与IntentService有什么区别？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1. 首先IntentService是继承自Service;</div><div class="line">2. Service不是一个单独的进程，它和应用程序在同一个进程中；</div><div class="line">3. Service也不是一个线程，所以我们要避免在Service中进行耗时的操作；</div><div class="line">4. IntentService使用队列的方式将请求的Intent加入队列，然后开启了一个Worker Thread（工作线程）在处理队列中的Intent,对于异步的startService请求，</div><div class="line">IntentService会处理完成一个之后在处理第二个，每一个请求都会在一个单独的Worker Thread中处理，不会阻塞应用程序的主线程。</div><div class="line">因此，如果我们如果要在Service里面处理一个耗时的操作，我们可以用IntentService来代替使用。</div><div class="line">5. 使用IntentService 必须首先继承IntentService并实现onHandleIntent()方法，将耗时的任务放在这个方法执行，其他方面，IntentService和Service一样。</div></pre></td></tr></table></figure>
<p><strong>101.Intent的实现原理是什么？为什么可以通过Intent去启动Service或者Activity？</strong></p>
<p><strong>102.有哪几种方式可以实习自定义控件？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.继承ViewGroud</div><div class="line">2.继承View</div><div class="line">3.组合控件</div></pre></td></tr></table></figure>
<p><strong>103.在代码中注册广播和在AndroidManifest.xml中注册广播有什么区别？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1)在代码不是常驻型广播，也就是说广播跟随程序的生命周期。</div><div class="line">2)在AndroidManifest是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</div></pre></td></tr></table></figure>
<p><strong>104.Android的事件分发机制是怎么样的？onInterceptTouchEvent、dispathchTouchEvent、onTouchEvent它们的执行顺序是怎样的，返回值有什么含义？</strong></p>
<p>105.堆和栈的区别是什么？</p>
<p>详情：<a href="https://zhidao.baidu.com/question/986901415975986739.html?fr=iks&amp;word=java+%B6%D1%BA%CD%D5%BB%B5%C4%C7%F8%B1%F0&amp;ie=gbk" target="_blank" rel="external">https://zhidao.baidu.com/question/986901415975986739.html?fr=iks&amp;word=java+%B6%D1%BA%CD%D5%BB%B5%C4%C7%F8%B1%F0&amp;ie=gbk</a></p>
<p><strong>106.Android中有哪些回调机制？并写出一个简单的例子。</strong></p>
<p><strong>108.一个有N个元素的一维数组（A[0] , A[1],..,A[n-1]）,设计一个算法求解该数组最大子数组。（要求时间复杂度是O(n) ）。</strong></p>
<p><strong>109.描述自己的一个项目，要求画出结构图，UML图，详细描述项目中的技术点，技术难点以及解决方案。</strong></p>
<p><strong>110.启动一个程序，可以主界面点击图标进入，也可从一个程序中跳转过去，二者有什么区别？</strong></p>
<p>112.横竖屏切换时候Activity的生命周期。</p>
<p>113.自定义View怎么做能提高效率？自定义view如何做图片缓存？自定义view如何判断单击和双击？自定义view的onDraw方法主要做什么？</p>
<p>114.进程与线程之间的联系与区别？</p>
<p>115.谈谈对设计模式的认识与理解，简单介绍一下你所知道的设计模式。</p>
<p>116.内部类的作用。</p>
<p>117.父类的静态方法能否被子类重写，为什么？</p>
<p>118.哪些情况下的对象会被垃圾回收机制处理掉。</p>
<p>119.Activity 、window、view 三者的差别，fragment的特点？</p>
<p><strong>120.如何保证service在后台不被kill ?</strong></p>
<p><strong>1.onStartCommand方法，返回START_STICKY</strong></p>
<p>StartCommond几个常量参数简介：</p>
<p>1、START_STICKY</p>
<p>在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。不久后service就会再次尝试重新创建，因为保留在开始状态，在创建     service后将保证调用onstartCommand。如果没有传递任何开始命令给service，那将获取到null的intent。</p>
<p>2、START_NOT_STICKY</p>
<p>在运行onStartCommand后service进程被kill后，并且没有新的intent传递给它。Service将移出开始状态，并且直到新的明显的方法（startService）调用才重新创建。因为如果没有传递任何未决定的intent那么service是不会启动，也就是期间onstartCommand不会接收到任何null的intent。</p>
<p>3、START_REDELIVER_INTENT</p>
<p>在运行onStartCommand后service进程被kill后，系统将会再次启动service，并传入最后一个intent给onstartCommand。直到调用stopSelf(int)才停止传递intent。如果在被kill后还有未处理好的intent，那被kill后服务还是会自动启动。因此onstartCommand不会接收到任何null的intent。</p>
<p><strong>2.当然也还有其他解决方案</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1.在onDestory方法中重启Service服务，一般来说，这样做是可以的。但是如果这样----》设置--&gt;下载--&gt;强制停止。则不会执行ondestory方法，或者通过别人应用，如360直接kill掉我的应用时，也是不会调用Service的ondestory方法的。　　</div><div class="line"></div><div class="line">2.修改AndroidManifest.xml　　</div><div class="line">&lt;manifest  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;　　android:sharedUserId=&quot;android.uid.system&quot;&gt;　　</div><div class="line">&lt;application android:icon=&quot;@drawable/icon&quot;　　</div><div class="line">android:label=&quot;@string/app_name&quot; </div><div class="line">android:allowClearUserData=&quot;false&quot;　　</div><div class="line">android:process=&quot;system&quot;  </div><div class="line">android:killAfterRestore=&quot;false&quot;&gt;　　</div><div class="line">如果在加入了此部分代码，表示该程序运行在system进程组中，system进程组是没有权限访问sd卡的，而且service是不会自动重启的。　　</div><div class="line"></div><div class="line">3.提高service的优先级别,不管你service的优先级别有多高,用户都是可以手动杀死的</div></pre></td></tr></table></figure>
<p>121.如何加载ndk库？如何在jni 中注册native函数，有几种注册方法？</p>
<p>122.简述软件编译流程和发布流程。</p>
<p><strong>123.短信监听如何实现？</strong></p>
<p>详情：<a href="http://www.itnose.net/detail/6132802.html" target="_blank" rel="external">http://www.itnose.net/detail/6132802.html</a></p>
<p>124.至少3种H5与原生APP的交互实现方式</p>
<p>125.请举例Android属性动画的属性的作用。</p>
<p>126.Android 客户端的缓存设计实现。</p>
<p>127.如何保证客户端的设备码唯一性？</p>
<p>128.Android 如何适配所有屏幕分辨率和屏幕尺寸？</p>
<p>129.Android 6.0删除了HttpClient ( org.apache.http.*) 的API ，如何处理兼容性问题。</p>
<p>130.列举Android design 中的View 和 使用方法（最少3种）</p>
<p>131.如何处理网络图片，并在所有屏幕展示高清图？</p>
<p>132.对比 Volley ，OKHttp， asynchttpclient ，xutils 的网络处理的区别。</p>
<p>133.分别写出Android的基础架构，四大组件以及最常用的四个布局</p>
<p>134.Activity的启动模式有哪几种？在哪里定义。它的生命周期有哪些？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">在android里，有4种activity的启动模式，分别为： </div><div class="line">“standard” (默认) </div><div class="line">“singleTop” </div><div class="line">“singleTask” </div><div class="line">“singleInstance”</div><div class="line">当应用运行起来后就会开启一条线程，线程中会运行一个任务栈，当Activity实例创建后就会放入任务栈中。Activity启动模式的设置在AndroidManifest.xml文件中，通过配置Activity的属性android:launchMode=&quot;&quot;设置。</div><div class="line">1. Standared模式（默认）</div><div class="line">我们平时直接创建的Activity都是这种模式的Activity，这种模式的Activity的特点是：只要你创建了Activity实例，一旦激活该Activity，则会向任务栈中加入新创建的实例，退出Activity则会在任务栈中销毁该实例。</div><div class="line">2. SingleTop模式</div><div class="line">这种模式会考虑当前要激活的Activity实例在任务栈中是否正处于栈顶，如果处于栈顶则无需重新创建新的实例，会重用已存在的实例，否则会在任务栈中创建新的实例。</div><div class="line">3. SingleTask模式</div><div class="line">如果任务栈中存在该模式的Activity实例，则把栈中该实例以上的Activity实例全部移除，调用该实例的newInstance()方法重用该Activity，使该实例处於栈顶位置，否则就重新创建一个新的Activity实例。</div><div class="line">4. SingleInstance模式</div><div class="line">当该模式Activity实例在任务栈中创建后，只要该实例还在任务栈中，即只要激活的是该类型的Activity，都会通过调用实例的newInstance()方法重用该Activity，此时使用的都是同一个Activity实例，它都会处于任务栈的栈顶。此模式一般用于加载较慢的，比较耗性能且不需要每次都重新创建的Activity。</div></pre></td></tr></table></figure>
<p>135.Application 是什么，有什么作用？</p>
<p>136.Android 的数据存储方式有哪些？</p>
<p>137.请跟据自己的理解，解析一下数据签名。</p>
<p>138.Android 应用中通知UI更新的方式有哪些？</p>
<p>139.请编写一个观察者模式的程序。</p>
<p>140.谈谈MVC ,MVP 模式的原理，在Android中是如何使用的？</p>
<p>141.Android ListView GrideVIew中加载大量的图片，如何避免OOM 和 快速滑动中出现的卡顿问题，可以从哪些方面优化用户体验？</p>
<p>142.Android 系统中GC什么情况下会出现内存泄露（举出几种情况即可）？</p>
<p>143.请简述一下你对NDK的理解</p>
<p>144.View , SurfaceView , GLSurfaceVIew的区别是什么？</p>
<p>145.Android 如何读取raw目录下的数据库文件？</p>
<p>146.Android 反射机制和原理</p>
<p>147.AIDL 的全称是什么、如何工作、能处理那些数据类型？</p>
<p>148.Android如何检测删除的文件是文件夹还是文件，如何删 除？</p>
<p>149.Android动画有哪些类型？</p>
<p>150.Android 绘制原理：onMeasure onLayout onDraw 作 用？</p>
<p>151.显式意图和隐式意图区别，隐式意图的使用？</p>
<p>152.Intent可以加入什么数据？是否能放入Bitmap?</p>
<p>153.写出一个单例？</p>
<p>154.Java 中==和 equals 的区别？</p>
<p>155.是否使用过本地广播，和全局广播有什么差</p>
<p>156.判断两个String的交集，比如A = “YesterDay ‘ B = Thursday”，交集为stday ,写个算法？</p>
<p>157.Android系统中GC什么悄况下会出现内存泄漏(举出几种情况即 可)？</p>
<p>158.请简述一下你对NDK的理解</p>
<p>159.有一个整数数组，有负数和整数，用一个方法把正负数分开，要求 空间复杂度是0(1),时间复杂度是：〇(N)</p>
<p>160.用Java实现一个二分查找算法</p>
<p>161.面向对象的特征有哪些方面，简单介绍一下。</p>
<p>162.abstract  class  和 interface 有什么区别？</p>
<p>163.GC 是什么？为什么要有GC?</p>
<p>164.什么情况会导致Force Close ？ 如何避免？ 能否捕获导致其的异常？</p>
<p>165.如何退出 Activity ？ 如何安全退出已调用多个Activity的Application?</p>
<p>166.什么是ANR 如何避免它？</p>
<p>167.AndroidManifest.xml 文件中主要包含哪些信息？</p>
<p>168.java 创建对象的有哪几种方式？分别写出来。</p>
<p>169.java 中的final 关键字有哪些用法？</p>
<p>170.String s=new String( “ xyz “)；创建了几个字符窜对象？请详细描述</p>
<p>171.Android 引入广播机制的用意？</p>
<p>172.说说MVC模式的原理，它在android中的运用</p>
<p>173.请给出算法判断一字符串是不是对称的，如：abccba</p>
<p>174.在android 中，请简述jni 的调用过程。</p>
<p>175.简述Android 应用程序结构是哪些？Android 应用程序结构是：</p>
<p>176.请通过案例来说明Comparable 和 Comparator的区别。</p>
<p>178.谈谈你对采用组合类的方式和采用继承的方式两种设计方法的理解？</p>
<p>179.Toobar是从Android哪个版本开始引入的？请从你个人的角度简述对于ActionBar向ToolBar演进的理解</p>
<p>180.</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/01/16/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="weihuan chen" />
          <p class="site-author-name" itemprop="name">weihuan chen</p>
          <p class="site-description motion-element" itemprop="description">it is my first time to build blog website</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-面试选题题库："><span class="nav-number">1.</span> <span class="nav-text">Android 面试选题题库：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-笔试题"><span class="nav-number">1.1.</span> <span class="nav-text">1.笔试题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-填空题"><span class="nav-number">1.2.</span> <span class="nav-text">2.填空题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-面试题"><span class="nav-number">1.3.</span> <span class="nav-text">3.面试题</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">weihuan chen</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script>
      <!-- UY END -->
  




  
  

  

  

  

  


</body>
</html>
